// ==============================
// FILE: vercel.json  (repo root)
// ==============================
{
  "crons": [
    { "path": "/api/cron/snapshot", "schedule": "*/5 * * * 1-5" }
  ]
}

// ==============================
// FILE: package.json  (merge these deps; keep your existing fields)
// ==============================
// {
//   "dependencies": {
//     "@aws-sdk/client-dynamodb": "^3.653.0",
//     "@aws-sdk/lib-dynamodb": "^3.653.0",
//     "papaparse": "^5.4.1"
//   }
// }

// ==============================
// FILE: lib/market-hours.ts
// ==============================
export type Phase = "PREMARKET" | "REGULAR" | "AFTERHOURS" | "CLOSED";

/** US market phase using America/New_York time. */
export function getMarketPhaseET(now = new Date()): Phase {
  const fmt = new Intl.DateTimeFormat("en-US", {
    timeZone: "America/New_York",
    hour12: false,
    hour: "2-digit",
    minute: "2-digit"
  });
  const [h, m] = fmt.format(now).split(":").map(Number);
  const minutes = h * 60 + m;
  const t = (H:number,M:number)=>H*60+M;
  if (minutes >= t(7,0)  && minutes < t(9,30)) return "PREMARKET";
  if (minutes >= t(9,30) && minutes < t(16,0)) return "REGULAR";
  if (minutes >= t(16,0) && minutes < t(20,0)) return "AFTERHOURS";
  return "CLOSED";
}

// ==============================
// FILE: lib/ddb.ts  (server-only DynamoDB helpers)
// ==============================
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { DynamoDBDocumentClient, PutCommand } from "@aws-sdk/lib-dynamodb";

const REGION = process.env.AWS_REGION!;
const TABLE_SNAPSHOTS = process.env.DDB_TABLE_SNAPSHOTS!;
const TABLE_NEWS = process.env.DDB_TABLE_NEWS!;

if (!REGION || !TABLE_SNAPSHOTS || !TABLE_NEWS) {
  throw new Error("Missing AWS/DynamoDB env vars.");
}

const ddb = DynamoDBDocumentClient.from(new DynamoDBClient({ region: REGION }), {
  marshallOptions: { removeUndefinedValues: true }
});

export async function putSnapshot(item: {
  Ticker: string;
  Ts: string;            // ISO
  Price?: number;
  PremarketGapPct?: number;  // weâ€™ll map Finviz 'change' here for now
  RelVol?: number;
  FloatShares?: number;
  RSI?: number | null;
  MarketPhase: string;
  Raw?: any;
}) {
  await ddb.send(new PutCommand({ TableName: TABLE_SNAPSHOTS, Item: item }));
}

// (News table is for Step 2)
export async function upsertNews(item: {
  HeadlineHash: string;
  Ticker: string;
  Ts: string;
  Headline: string;
  Source?: string;
  Url?: string;
}) {
  await ddb.send(new PutCommand({ TableName: TABLE_NEWS, Item: item }));
}

// ==============================
// FILE: lib/finviz-export.ts  (server-only CSV fetch + parse)
// ==============================
import Papa from "papaparse";

const EXPORT_URL = process.env.FINVIZ_EXPORT_URL!;
if (!EXPORT_URL) throw new Error("FINVIZ_EXPORT_URL is missing.");

function toNumber(x: any) {
  if (x === null || x === undefined) return undefined;
  const s = String(x).replace(/[%,$ ]/g, "");
  const n = Number(s);
  return Number.isFinite(n) ? n : undefined;
}
function key(s: string) {
  return s.trim().toLowerCase().replace(/\s+/g, "");
}

/** Fetches the CSV from Finviz Elite and returns normalized rows. */
export async function fetchFinvizExport(): Promise<Array<any>> {
  // If you end up needing a Cookie header, add: headers: { Cookie: process.env.FINVIZ_COOKIE! }
  const res = await fetch(EXPORT_URL, { cache: "no-store" as any });
  if (!res.ok) {
    const txt = await res.text();
    throw new Error(`Finviz export failed: ${res.status} ${txt?.slice(0,200)}`);
  }
  const csv = await res.text();
  const parsed = Papa.parse(csv, { header: true, skipEmptyLines: true });
  if (parsed.errors?.length) throw new Error("CSV parse error: " + parsed.errors[0].message);

  const rows: any[] = [];
  for (const r of parsed.data as any[]) {
    const o: any = {};
    for (const k of Object.keys(r)) o[key(k)] = r[k];

    rows.push({
      raw: r,
      ticker: o.ticker || o.symbol,
      price: toNumber(o.price),
      change_pct: toNumber(o.change || o.changepct || o.changepercent),
      relative_volume: toNumber(o.relativevolume || o.rvol || o.relvolume),
      float_shares_m: toNumber(o.float || o.sharesfloat || o.floatshares),
      rsi: toNumber(o.rsi || o.rsi14),
      sector: o.sector,
      company: o.company
    });
  }
  return rows;
}

// ==============================
// FILE: app/api/finviz/ping/route.ts  (optional connectivity test)
// ==============================
export const runtime = "nodejs";
export const dynamic = "force-dynamic";
import { fetchFinvizExport } from "@/lib/finviz-export";

export async function GET() {
  try {
    const rows = await fetchFinvizExport();
    return new Response(JSON.stringify({ ok: true, sample: rows.slice(0, 3) }), {
      headers: { "content-type": "application/json" }
    });
  } catch (e: any) {
    return new Response(JSON.stringify({ ok: false, error: String(e?.message || e) }), { status: 500 });
  }
}

// ==============================
// FILE: app/api/cron/snapshot/route.ts
// ==============================
import { NextResponse } from "next/server";
export const runtime = "nodejs";
export const dynamic = "force-dynamic";

import { getMarketPhaseET } from "@/lib/market-hours";
import { fetchFinvizExport } from "@/lib/finviz-export";
import { putSnapshot } from "@/lib/ddb";

export async function GET() {
  try {
    const phase = getMarketPhaseET(new Date());
    if (phase === "CLOSED") {
      return NextResponse.json({ ok: true, skipped: "market closed" });
    }

    const rows = await fetchFinvizExport();
    if (!rows?.length) return NextResponse.json({ ok: true, count: 0 });

    const ts = new Date().toISOString();
    for (const r of rows) {
      if (!r.ticker) continue;
      await putSnapshot({
        Ticker: r.ticker,
        Ts: ts,
        Price: r.price,
        PremarketGapPct: r.change_pct,      // using 'change' for now
        RelVol: r.relative_volume,
        FloatShares: r.float_shares_m ? Math.round(r.float_shares_m * 1_000_000) : undefined,
        RSI: r.rsi ?? null,
        MarketPhase: phase,
        Raw: r.raw
      });
    }

    return NextResponse.json({ ok: true, count: rows.length, ts });
  } catch (err: any) {
    console.error("snapshot error", err);
    return NextResponse.json({ ok: false, error: String(err?.message || err) }, { status: 500 });
  }
}
